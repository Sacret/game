<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <title>Tetris</title>

  <!-- <link rel="stylesheet" href="assets/styles/main.css"> -->

</head>
<body>
  <div id="root" />

  <script>
    const ROW_LENGTH = 20;
    const COLUMN_LENGTH = 10;
    const FIGURES_COUNT = 7;

    const START_POSITION = 3;

    const EMPTY_CELL = '□';
    const FILLED_CELL = '■';

    const LEFT_ARROW = 37;
    const UP_ARROW = 38;
    const RIGHT_ARROW = 39;
    const DOWN_ARROW = 40;

    const EMPTY_FIELD =  [...Array(ROW_LENGTH)].map(
      row => [...Array(COLUMN_LENGTH)].map(column => false)
    );

    const rootElem = document.getElementById('root');

    let interval = 1000;
    let speedInterval = 100;

    const field = EMPTY_FIELD;

    const figures = {
      0: [
        [false, false, false, false],
        [true, true, true, true]
      ], // I
      1: [
        [true, false, false],
        [true, true, true]
      ], // J
      2: [
        [false, false, true],
        [true, true, true]
      ], // L
      3: [
        [true, true],
        [true, true]
      ], // O
      4: [
        [false, true, true],
        [true, true, false]
      ], // S
      5: [
        [false, true, false],
        [true, true, true]
      ], // T
      6: [
        [true, true, false],
        [false, true, true]
      ], // Z
    };

    let step = 0;
    let currentPosition = START_POSITION;
    let figure = null;
    let figureField = EMPTY_FIELD;
    let isDownPressed = false;

    document.addEventListener('keydown', (e) => {
      const event = e = e || window.event;
      const code = event.keyCode;

      if (code === LEFT_ARROW) {
        const minPosition = 0;
        if (!isFieldLeftTouch()) {
          currentPosition = currentPosition <= minPosition
          ? minPosition
          : currentPosition - 1;
        }
        setFigureField(step - 1);
      } else if (code == RIGHT_ARROW) {
        const maxPosition = COLUMN_LENGTH - figure[0].length;
        if (!isFieldRightTouch()) {
          currentPosition = currentPosition >= maxPosition
            ? maxPosition
            : currentPosition + 1;
        }
        setFigureField(step - 1);
      } else if (code === DOWN_ARROW) {
        isDownPressed = true;
      }
    });

    document.addEventListener('keyup', (e) => {
      const event = e = e || window.event;
      const code = event.keyCode;

      if (code === DOWN_ARROW) {
        isDownPressed = false;
      }
    });

    const printField = () => {
      let strField = '';
      for (let i = 0; i < ROW_LENGTH; i++) {
        for (let j = 0; j < COLUMN_LENGTH; j++) {
          strField += (field[i][j] || figureField[i][j])
            ? FILLED_CELL
            : EMPTY_CELL;
        }
        strField += '\n';
      }
      rootElem.innerText = strField;
    };

    const mergeFields = () => {
      for (let i = 0; i < ROW_LENGTH; i++) {
        for (let j = 0; j < COLUMN_LENGTH; j++) {
          field[i][j] = field[i][j] || figureField[i][j];
        }
      }
    }

    const getRandomFigure = () => {
      let rand = Math.random() * FIGURES_COUNT - 0.5;
      return figures[Math.round(rand)];
    };

    const setFigureField = (currentStep) => {
      const [firstRow, secondRow] = figure;

      figureField = [...Array(ROW_LENGTH)].map(
        (_, row) => [...Array(COLUMN_LENGTH)].map((_, column) => {
          if (row === currentStep - 1) {
            return (column >= currentPosition && column < currentPosition + firstRow.length)
              ? firstRow[column - currentPosition]
              : false;
          } else if (row === currentStep) {
            return (column >= currentPosition && column < currentPosition + secondRow.length)
              ? secondRow[column - currentPosition]
              : false;
          }
          return false;
        })
      );

      printField();
    }

    const isFieldBottomTouch = () => {
      for (let i = 0; i < figure.length; i++) {
        for (let j = 0; j < figure[i].length; j++) {
          const currentCell = figure[i][j];

          if (!currentCell) continue;

          if (step === ROW_LENGTH) return true;

          if (field[step - 1 + i] && field[step - 1 + i][currentPosition + j]) {
            return true;
          }
        }
      }

      return false;
    };

    const isFieldLeftTouch = () => {
      for (let i = 0; i < figure.length; i++) {
        for (let j = 0; j < figure[i].length; j++) {
          const currentCell = figure[i][j];

          if (!currentCell) continue;

          if (field[step - 2 + i] && field[step - 2 + i][currentPosition + j - 1]) {
            return true;
          }

          break;
        }
      }

      return false;
    };

    const isFieldRightTouch = () => {
      for (let i = 0; i < figure.length; i++) {
        for (let j = figure[i].length -1; j >= 0; j--) {
          const currentCell = figure[i][j];

          if (!currentCell) continue;

          if (field[step - 2 + i] && field[step - 2 + i][currentPosition + j + 1]) {
            return true;
          }

          break;
        }
      }

      return false;
    };

    const startGame = () => {
      const gameCallback = () => {
        if (step === 0) {
          figure = getRandomFigure();
          figureField = EMPTY_FIELD;
        }

        if (isFieldBottomTouch()) {
          console.log(`step: ${step}; isFieldBottomTouch: true`);
          mergeFields();
          step = 0;
          currentPosition = START_POSITION;
        } else {
          setFigureField(step);
          step++;
        }

        setTimeout(gameCallback, isDownPressed ? speedInterval : interval);
      };

      setTimeout(gameCallback, interval);
    };

    startGame();
  </script>
</body>
</html>
