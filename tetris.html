<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <title>Tetris</title>

  <link rel="stylesheet" href="styles.css">

</head>
<body>
  <div class="brick">
    <div class="top">
      <div class="screen">
        <div id="game"></div>
        <div class="game-info">
          <div class="score-text">Score</div>
          <div id="score">0</div>
        </div>
      </div>
    </div>
    <div class="center"></div>
    <div class="bottom">
      <div class="horizontal-buttons">
        <div class="button small"></div>
        <div class="button small"></div>
        <div class="button small"></div>
        <div class="button small"></div>
      </div>
      <div class="control-buttons">
        <div class="arrow-buttons">
          <div class="button top medium"></div>
          <div class="line-buttons">
            <div class="button left medium"></div>
            <div class="button right medium"></div>
          </div>
          <div class="button bottom medium"></div>
        </div>
        <div class="button rotate big"></div>
      </div>
    </div>
  </div>

  <script>
    const ROW_LENGTH = 20;
    const COLUMN_LENGTH = 10;
    const FIGURES_COUNT = 7;

    const START_POSITION = 3;
    const START_INTERVAL = 1000;
    const DIFF_INTERVAL = 50;
    const MIN_INTERVAl = 0;

    const CELL = 'â–£';

    const LEFT_ARROW = 37;
    const UP_ARROW = 38;
    const RIGHT_ARROW = 39;
    const DOWN_ARROW = 40;
    const SPACE = 32;

    const SCORES_LEVEL = {
      0: 0,
      1: 100,
      2: 300,
      3: 700,
      4: 1500,
    };

    const EMPTY_FIELD =  [...Array(ROW_LENGTH)].map(
      row => [...Array(COLUMN_LENGTH)].map(column => false)
    );

    const gameElem = document.getElementById('game');
    const scoresElem = document.getElementById('score');

    let figuresCount = 0;
    let interval = START_INTERVAL;
    let speedInterval = 100;
    let currentInterval = interval;
    let scores = 0;
    let currentTimeout = null;

    let field = EMPTY_FIELD;

    const figures = {
      0: [
        [false, false, false, false],
        [true, true, true, true]
      ], // I
      1: [
        [true, false, false],
        [true, true, true]
      ], // J
      2: [
        [false, false, true],
        [true, true, true]
      ], // L
      3: [
        [true, true],
        [true, true]
      ], // O
      4: [
        [false, true, true],
        [true, true, false]
      ], // S
      5: [
        [false, true, false],
        [true, true, true]
      ], // T
      6: [
        [true, true, false],
        [false, true, true]
      ], // Z
    };

    let step = 0;
    let currentPosition = START_POSITION;
    let figure = null;
    let figureField = EMPTY_FIELD;
    let isDownPressed = false;

    document.addEventListener('keydown', (e) => {
      const event = e = e || window.event;
      const code = event.keyCode;

      if (code === LEFT_ARROW) {
        const minPosition = 0;
        if (!isFieldLeftTouch()) {
          currentPosition = currentPosition <= minPosition
          ? minPosition
          : currentPosition - 1;
        }
        setFigureField(step - 1);
      } else if (code == RIGHT_ARROW) {
        const maxPosition = COLUMN_LENGTH - getMaxPosition(figure);
        if (!isFieldRightTouch()) {
          currentPosition = currentPosition >= maxPosition
            ? maxPosition
            : currentPosition + 1;
        }
        setFigureField(step - 1);
      } else if (code === DOWN_ARROW) {
        currentInterval = speedInterval;
        clearTimeout(currentTimeout);
        gameCallback();
      } else if (code === UP_ARROW) {
        rotateFigure();
        setFigureField(step - 1);
      } else if (code === SPACE) {
        currentInterval = MIN_INTERVAl;
        clearTimeout(currentTimeout);
        gameCallback();
      }
    });

    document.addEventListener('keyup', (e) => {
      const event = e = e || window.event;
      const code = event.keyCode;

      if (code === DOWN_ARROW) {
        currentInterval = interval;
      }
    });

    const printField = () => {
      let strField = '';
      for (let i = 0; i < ROW_LENGTH; i++) {
        for (let j = 0; j < COLUMN_LENGTH; j++) {
          strField += (field[i][j] || figureField[i][j])
            ? `<span class="cell filled">${CELL}</span>`
            : `<span class="cell empty">${CELL}</span>`;
        }
        strField += '\n';
      }
      gameElem.innerHTML = strField;
    };

    const mergeFields = () => {
      let rowCount = 0;
      let rowFilledCount = 0;
      const newField = [];

      for (let i = 0; i < ROW_LENGTH; i++) {
        let row = [];
        for (let j = 0; j < COLUMN_LENGTH; j++) {
          row[j] = field[i][j] || figureField[i][j];
        }
        if (!row.every(elem => elem)) {
          newField[rowCount] = row;
          rowCount++;
        }
        if (row.some(elem => elem)) {
          rowFilledCount++;
        }
      }

      const rowDiff = field.length - newField.length;
      let newItems = [];

      if (rowDiff) {
        newItems = [...Array(rowDiff)].map(
          row => [...Array(COLUMN_LENGTH)].map(column => false)
        );
        scores += SCORES_LEVEL[rowDiff];
      }

      if (rowFilledCount === ROW_LENGTH) {
        scoresElem.innerText = `You lost, ${scores.toString()}`;
      } else if (rowFilledCount === 0) {
        scoresElem.innerText = `You win, ${scores.toString()}`;
      } else {
        scoresElem.innerText = scores.toString();
      }

      if (currentInterval === MIN_INTERVAl) {
        currentInterval = interval;
      }

      field = [...newItems, ...newField];
    }

    const getRandomFigure = () => {
      if (figuresCount % 10 === 0) {
        interval = interval - DIFF_INTERVAL > speedInterval ? interval - DIFF_INTERVAL : speedInterval;
      }
      figuresCount++;

      let rand = Math.random() * FIGURES_COUNT - 0.5;
      return figures[Math.round(rand)];
    };

    const getMaxPosition = (currentFigure) => {
      let maxPosition = 0;

      for (let i = 0; i < currentFigure.length; i++) {
        for (let j = 0; j < currentFigure[0].length; j++) {
          if (currentFigure[i][j] && (j + 1) > maxPosition) {
            maxPosition = j + 1;
          }
        }
      }

      return maxPosition;
    }

    const rotateFigure = () => {
      const newFigure = [];
      const figureRows = figure.length;
      const figureColumns = figure[0].length;

      for (let i = 0; i < figureRows; i++) {
        for (let j = 0; j < figureColumns; j++) {
          if (!newFigure[j]) {
            newFigure[j] = [];
          }

          newFigure[j][figureRows - 1 - i] = figure[i][j];
        }
      }

      const nextStep = step - (figureRows - newFigure.length);
      step = nextStep < ROW_LENGTH ? nextStep : ROW_LENGTH;

      const nextPosition = currentPosition - (figureColumns - newFigure[0].length);
      const maxPosition = COLUMN_LENGTH - getMaxPosition(newFigure);
      if (nextPosition >= maxPosition) {
        currentPosition = maxPosition;
      } else if (nextPosition <= 0) {
        currentPosition = 0;
      }

      figure = newFigure;
    };

    const setFigureField = (currentStep) => {
      figureField = [...Array(ROW_LENGTH)].map(
        (_, row) => [...Array(COLUMN_LENGTH)].map((_, column) => {
          const rowDiff = currentStep - row;
          const figureRows = figure.length;
          const figureColumns = figure[0].length;

          if (rowDiff < figureRows) {
            const columnDiff = column - currentPosition;
            const figureRow = figure[figureRows - 1 - rowDiff];

            return (columnDiff >= 0 && columnDiff < figureColumns && figureRow)
              ? figureRow[columnDiff]
              : false;
          }

          return false;
        })
      );

      printField();
    }

    const isFieldBottomTouch = () => {
      const figureRows = figure.length;

      for (let i = 0; i < figureRows; i++) {
        for (let j = 0; j < figure[i].length; j++) {
          const currentCell = figure[i][j];

          if (!currentCell) continue;

          if (step >= ROW_LENGTH) return true;

          const fieldRow = field[step - figureRows + 1 + i];

          if (fieldRow && fieldRow[currentPosition + j]) {
            return true;
          }
        }
      }

      return false;
    };

    const isFieldLeftTouch = () => {
      const figureRows = figure.length;

      for (let i = 0; i < figureRows; i++) {
        for (let j = 0; j < figure[i].length; j++) {
          const currentCell = figure[i][j];

          if (!currentCell) continue;

          const fieldRow = field[step - figureRows + i];

          if (fieldRow && fieldRow[currentPosition + j - 1]) {
            return true;
          }

          break;
        }
      }

      return false;
    };

    const isFieldRightTouch = () => {
      const figureRows = figure.length;

      for (let i = 0; i < figureRows; i++) {
        for (let j = figure[i].length -1; j >= 0; j--) {
          const currentCell = figure[i][j];

          if (!currentCell) continue;

          const fieldRow = field[step - figureRows + i];

          if (fieldRow && fieldRow[currentPosition + j + 1]) {
            return true;
          }

          break;
        }
      }

      return false;
    };

    const gameCallback = () => {
      if (step === 0) {
        figure = getRandomFigure();
        figureField = EMPTY_FIELD;
      }

      if (isFieldBottomTouch()) {
        mergeFields();
        step = 0;
        currentPosition = START_POSITION;
      } else {
        setFigureField(step);
        step++;
      }

      currentTimeout = setTimeout(gameCallback, currentInterval);
    };

    gameCallback();
  </script>
</body>
</html>
